package execExploits
import(
	"../interfaceExploit"
	"os/exec"
	"io/ioutil"
	"strings"
	"os"
	"log"
	"bufio"
	"fmt"
	"time"
	"bytes"
)
func AddTeam(index int, nameGroup string){
	for _,team:= range interfaceExploit.Exploits[index].Teams{
		if team.Name==nameGroup{
			return
		}
	}
	exploitName:=interfaceExploit.Exploits[index].Name
	newTeam:=interfaceExploit.NewTeamInfo(nameGroup)
	interfaceExploit.Exploits[index].Teams=append(interfaceExploit.Exploits[index].Teams, newTeam)
	file,err := os.OpenFile(interfaceExploit.DirExploits+"/"+exploitName+"."+interfaceExploit.TeamFileExtension, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
	    log.Fatal(err)
	}
	defer file.Close()
	_,err= file.WriteString(nameGroup+"\n")
	if err != nil {
	    log.Fatal(err)
	}
	file.Sync()
}

func RemoveTeam(index int, nameGroup string){
	for i,team:= range interfaceExploit.Exploits[index].Teams{
		if team.Name==nameGroup{
			exploitName:=interfaceExploit.Exploits[index].Name
			interfaceExploit.Exploits[index].Teams=append(interfaceExploit.Exploits[index].Teams[:i] , interfaceExploit.Exploits[index].Teams[i+1:]...)
			path:=interfaceExploit.DirExploits+"/"+exploitName+"."+interfaceExploit.TeamFileExtension
			input, err := ioutil.ReadFile(path)
			if err != nil {
				log.Fatalln(err)
			}

			lines := strings.Split(string(input), "\n")

			for i, line := range lines {
				if line==nameGroup {
					lines= append(lines[:i],lines[i+1:]...)
				}
			}
			output := strings.Join(lines, "\n")
			err = ioutil.WriteFile(path, []byte(output), 0644)
			if err != nil {
				log.Fatalln(err)
			}
			break
		}
	}
}

func StartExploit(index int){
	interfaceExploit.Exploits[index].Active=true
}

func StopExploit(index int){
	interfaceExploit.Exploits[index].Active=false
}






func getNameExploit(file os.FileInfo) bool{
	extens:=strings.Split(file.Name(),".")[1]
	if(extens == interfaceExploit.TeamFileExtension ){
		return true
	}
	return false

}
func createTeamsFromFile( path string )[]interfaceExploit.TeamInfo{
	var teams []interfaceExploit.TeamInfo
	file, err := os.Open(path)
	if err != nil {
	    log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		teams=append(teams, interfaceExploit.NewTeamInfo(scanner.Text()))
	}

	if err := scanner.Err(); err != nil {
	    log.Fatal(err)
	}
	return teams
}

func CreateExploit(name string) interfaceExploit.ExploitInfo{
	teams:=createTeamsFromFile(interfaceExploit.DirExploits+"/"+name+"."+interfaceExploit.TeamFileExtension)
	var exploit = interfaceExploit.NewExploitInfo(name, interfaceExploit.DirExploits+"/"+name+"."+interfaceExploit.ExploitFileExtension, teams)
	return exploit
}


func AddExploitToList(exploit interfaceExploit.ExploitInfo){
	interfaceExploit.Exploits = append(interfaceExploit.Exploits,exploit)
}
func RemoveExploitFromList(name string){
	for i,exploit:= range interfaceExploit.Exploits{
		if exploit.Name==name{
			interfaceExploit.Exploits=append(interfaceExploit.Exploits[:i],interfaceExploit.Exploits[i+1:]...)
			break
		}
	}
}

//TODO nella cartella devono esserci un file .py e un file .teams
func addExploits(){
	files,err :=ioutil.ReadDir(interfaceExploit.DirExploits)
	if err!= nil{
		log.Fatal(err)
	}
	for _,file :=range files{
		if(getNameExploit(file)){
			exploit:= CreateExploit(strings.Split(file.Name(),".")[0])
			AddExploitToList(exploit)
		}
	}
}




func executeExploitOnTeam(path string, indexTeam int,indexExploit int){
	cmd:=exec.Command(path,interfaceExploit.Exploits[indexExploit].Name)
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Start()
	done:= make(chan error)
	go func(){ done <- cmd.Wait()}()
	var flag=interfaceExploit.FlagInfo{}
	select{
		case <-time.After(time.Duration(interfaceExploit.TimeTimeout)*time.Second):
			cmd.Process.Kill()
			flag.Status="INVALID"
		case err:=<-done:
			if err != nil {
				fmt.Println(err)
				flag.Status="INVALID"
			}else{
				sFlag:=strings.Replace(buf.String(),"\n","",-1)
				if (interfaceExploit.FlagRegex.MatchString(sFlag)){
					if(sFlag!= interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag[0].Flag){
						flag.Status="NEW"
						flag.Flag=sFlag
					}
				}else{
					flag.Status="INVALID"
					flag.Flag=sFlag
				}
			}
	}
	if  flag.Status=="NEW"{
		interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag=append([]interfaceExploit.FlagInfo{flag},interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag...)
	}
}
func executeExploit(indexExploit int){
	for indexTeam,_:= range interfaceExploit.Exploits[indexExploit].Teams{
		go executeExploitOnTeam(interfaceExploit.Exploits[indexExploit].Path,indexTeam,indexExploit)
	}


}

func executeExploits(){
	for indexExploit, exploit:= range interfaceExploit.Exploits{
		if(exploit.Active){
			go executeExploit(indexExploit)
		}
	}
}


func Loop(){
	addExploits()
	for {
		go executeExploits()
		fmt.Println("Executing Exploits")
		time.Sleep(time.Duration(interfaceExploit.TimeExploit) * time.Second)
	}
}

