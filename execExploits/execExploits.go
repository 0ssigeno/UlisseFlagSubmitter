package execExploits

import (
	"../interfaceExploit"
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"
)

func AddTeam(index int, nameGroup string) {
	for _, team := range interfaceExploit.Exploits[index].Teams {
		if team.Name == nameGroup {
			return
		}
	}
	exploitName := interfaceExploit.Exploits[index].Name
	newTeam := interfaceExploit.NewTeamInfo(nameGroup)
	interfaceExploit.Exploits[index].Teams = append(interfaceExploit.Exploits[index].Teams, newTeam)
	file, err := os.OpenFile(interfaceExploit.DirExploits+"/"+exploitName+"."+interfaceExploit.TeamFileExtension, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	_, err = file.WriteString(nameGroup + "\n")
	if err != nil {
		log.Fatal(err)
	}
	file.Sync()
}

func RemoveTeam(index int, nameGroup string) {
	for i, team := range interfaceExploit.Exploits[index].Teams {
		if team.Name == nameGroup {
			exploitName := interfaceExploit.Exploits[index].Name
			interfaceExploit.Exploits[index].Teams = append(interfaceExploit.Exploits[index].Teams[:i], interfaceExploit.Exploits[index].Teams[i+1:]...)
			path := interfaceExploit.DirExploits + "/" + exploitName + "." + interfaceExploit.TeamFileExtension
			input, err := ioutil.ReadFile(path)
			if err != nil {
				log.Fatalln(err)
			}

			lines := strings.Split(string(input), "\n")

			for i, line := range lines {
				if line == nameGroup {
					lines = append(lines[:i], lines[i+1:]...)
				}
			}
			output := strings.Join(lines, "\n")
			err = ioutil.WriteFile(path, []byte(output), 0644)
			if err != nil {
				log.Fatalln(err)
			}
			break
		}
	}
}

func StartExploit(index int) {
	interfaceExploit.Exploits[index].Active = true
}

func StopExploit(index int) {
	interfaceExploit.Exploits[index].Active = false
}

func getNameExploit(file os.FileInfo) bool {
	extens := strings.Split(file.Name(), ".")[1]
	if extens == interfaceExploit.TeamFileExtension {
		return true
	}
	return false

}
func createTeamsFromFile(path string) []interfaceExploit.TeamInfo {
	var teams []interfaceExploit.TeamInfo
	file, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		teams = append(teams, interfaceExploit.NewTeamInfo(scanner.Text()))
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
	return teams
}

func CreateExploit(name string) interfaceExploit.ExploitInfo {
	teams := createTeamsFromFile(interfaceExploit.DirExploits + "/" + name + "." + interfaceExploit.TeamFileExtension)
	var exploit = interfaceExploit.NewExploitInfo(name, interfaceExploit.DirExploits+"/"+name+"."+interfaceExploit.ExploitFileExtension, teams)
	return exploit
}

func AddExploitToList(exploit interfaceExploit.ExploitInfo) {
	interfaceExploit.Exploits = append(interfaceExploit.Exploits, exploit)
}
func RemoveExploitFromList(name string) {
	for i, exploit := range interfaceExploit.Exploits {
		if exploit.Name == name {
			interfaceExploit.Exploits = append(interfaceExploit.Exploits[:i], interfaceExploit.Exploits[i+1:]...)
			break
		}
	}
}

//TODO nella cartella devono esserci un file .py e un file .teams
func addExploits() {
	files, err := ioutil.ReadDir(interfaceExploit.DirExploits)
	if err != nil {
		log.Fatal(err)
	}
	for _, file := range files {
		if getNameExploit(file) {
			exploit := CreateExploit(strings.Split(file.Name(), ".")[0])
			AddExploitToList(exploit)
		}
	}
}

func contains(flags []interfaceExploit.FlagInfo, e string) bool {
	for _, a := range flags {
		if a.Flag == e {
			return true
		}
	}
	return false
}

func executeExploitOnTeam(path string, indexTeam int, indexExploit int) {
	cmd := exec.Command(path, interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Name)
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Start()
	done := make(chan error)
	go func() { done <- cmd.Wait() }()
	var flags = []interfaceExploit.FlagInfo{}
	select {
	case <-time.After(time.Duration(interfaceExploit.TimeTimeout) * time.Second):
		cmd.Process.Kill()
		//flag.Status="INVALID"
	case err := <-done:
		if err != nil {
			//	flag.Status="INVALID"
		} else {
			arrayFlags := strings.Split(buf.String(), "\n") //rimuovo pwntools 3
			for _, iterator := range arrayFlags {
				sFlag := strings.Replace(iterator, " ", "", -1)
				sFlag = strings.Replace(sFlag, "\n", "", -1)
				sFlag = strings.Replace(sFlag, "\t", "", -1)
				if interfaceExploit.FlagRegex.MatchString(sFlag) {
					//if(sFlag!= interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag[0].Flag){
					if !contains(interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag, sFlag) {
						var flag = interfaceExploit.FlagInfo{sFlag, "NEW"}
						flags = append(flags, flag)
					}
				}
			}
		}
	}
	interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag = append(flags, interfaceExploit.Exploits[indexExploit].Teams[indexTeam].Flag...)
}
func executeExploit(indexExploit int) {
	//for indexTeam,_:= range interfaceExploit.Exploits[indexExploit].Teams{
	//	go executeExploitOnTeam(interfaceExploit.Exploits[indexExploit].Path,indexTeam,indexExploit)
	//}
	//TODO Decidere di quanto fare il buffer :)
	teams := make(chan int, 20)
	// Creo il producer!
	go func() {
		for indexTeam, _ := range interfaceExploit.Exploits[indexExploit].Teams {
			teams <- indexTeam
		}
	}()
	// TODO: Numero di goroutine parametrico o una const!
	nGoroutines := 8
	wg := sync.WaitGroup{}
	wg.Add(nGoroutines)
	for i := 0; i < nGoroutines; i++ {
		go func() {
			defer wg.Done()
			for team := range teams {
				executeExploitOnTeam(interfaceExploit.Exploits[indexExploit].Path, team, indexExploit)
			}
		}()
	}
	wg.Wait()

}

func executeExploits() {
	for indexExploit, exploit := range interfaceExploit.Exploits {
		if exploit.Active {
			executeExploit(indexExploit)
		}
	}
}

func Loop() {
	addExploits()
	for {
		executeExploits()
		fmt.Println("Executing Exploits")
		//time.Sleep(time.Duration(interfaceExploit.TimeExploit) * time.Second)
	}
}
